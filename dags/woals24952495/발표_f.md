---
marp: true
theme: default
paginate: true
backgroundColor: #f6f6f6ff
style: |
  section {
    justify-content: flex-start;
  }
---

# **실시간 지하철 지연 분석 서비스**
### Real-time Subway Delay Analysis Service
<hr>
<br>
<br><br>

**김재민, 이찬구** 

---

## **1. 프로젝트 개요**
<hr>

### **1) 문제 정의 (Why)**

<br>

![width:800px](뉴스_기사_사진_경로) <!-- 여기에 준비하신 뉴스 기사 이미지를 넣어주세요 -->

<br><br>

> **"지하철이 어디 있는지는 알지만, 얼마나 늦는지는 모릅니다."**

- 단순한 위치 조회를 넘어, **공식 시간표**와 **실제 운행** 간의 **'지연 격차'** 를 실시간 추적
- 실시간 데이터를 가공하여 직관적인 **실시간 대시보드** 구현

---

## **1. 프로젝트 개요**
<hr>

<br>

### **2) 프로젝트 목표**

<br>

- **실시간 지연 랭킹**: 역별·호선별 지연 순위 대시보드 구현
- **정체 핫스팟 도출**: 실시간 정체 유발 **TOP 5개 역** 집중 분석 및 시각화
- **지연의 ‘ 골든타임’ 구간 분석**: 출근 시간대 등 지연이 집중되는 시간적/공간적 임계점 예측
- **맞춤형 데이터 제공**: 실시간 사용자 맞춤 환승역 비교 그래프 구현
<br><br><br><br>
---

## **1. 프로젝트 개요**
<hr>
<br>

### **3) 서비스 타겟**


#### 👤 **"오늘 1호선 연착이야?"**
매일 아침 포털에서 지연 정보를 검색하며 불안해하는 **출근길 직장인**

<br>

#### 👤 **"가장 리스크가 적은 노선은 어디지?"**
중요한 약속을 앞두고 지연 가능성이 낮은 최적의 경로를 택하고 싶은 **지하철 이용객**


---

## **2. 데이터 소개 및 정의**
<hr>

| 구분 | **실시간 데이터** | **시간표 데이터** |
| :--- | :--- | :--- |
| **수집 출처** | **서울 열린데이터 광장**<br>(실시간 열차 위치 API) | - **공공데이터 포털** (1~9호선 시각표.csv)<br>- **코레일** (경의·경춘·수인분당.csv)<br>- **공항철도** (공항철도.csv) |
| **수집 범위** | 1~9호선, 경의중앙선, 공항철도,<br>수인분당선, 경춘선 **(총 13개 노선)** | 1~9호선, 경의중앙선, 공항철도,<br>수인분당선, 경춘선 **(총 13개 노선)** |
| **수집 방식** | **REST API**<br>(1분마다 실행, 실시간성 확보) | 파일 업로드<br>(CSV 데이터 가공 및 적재) |
| **수집 기간** | 1월 15일, 16일<br>(테스트 : 1월 14일) | 2025년 시간표 업로드 |

<br>
<!--
- **데이터 특징**: 
  - **실시간**: 1분마다 적재되는 동적(Dynamic) 데이터 → **지연 실측치 추출**
  - **시간표**: 파편화된 출처의 데이터를 통합한 정적(Static) 데이터 → **지연 판단 기준점**
-->

---

## **3. 아키텍처 및 엔지니어링**
<hr>

<br>

### **1) 데이터 파이프라인**

<br>


- **Data Collection**: Python 기반 실시간 **데이터 수집 및 전처리**
- **Pipeline**: Git & Airflow를 활용한 **워크플로우 자동화**
- **Storage**: Supabase 클라우드 **DB 적재**
- **Visualization**: Redash를 활용한 SQL기반 **시각화**













---
## **3. 아키텍처 및 엔지니어링 ( ① 실시간 데이터 )**
<hr>

### **2) 데이터 전처리 및 변수화**




**- 주요 변수 선별 (n=9/13): 직관적인 영문명으로 통일 및 변수 최적화**


```python
all_records.append({
  # 기존 변수명 (API) -> 변경 변수명 (DB)
  "line_id": item.get("subwayId"),               -> 노선ID 
  "line_name": item.get("subwayNm"),             -> 노선명 
  "station_name": item.get("statnNm"),           -> 역명 
  "up_down": int(item.get("updnLine")),          -> 상하행(0, 1) 
  "train_code": item.get("trainNo"),             -> 열차 식별 번호 
  "train_status": int(item.get("trainSttus")),   -> 열차상태(0, 1, 2, 3) 
  "last_rec_time": parse(item.get("recptnDt")),  -> 마지막 수신시간 
  "dest_station_name": item.get("statnTnm")      -> 종착역 
  "is_express": int(item.get("directAt"))        -> 급행 여부(0, 1)
```
- **제외 항목 (n= 4):** station_id, is_last_train, last_rec_date, dest_station_id

---

## **3. 아키텍처 및 엔지니어링 ( ① 실시간 데이터 )**
<hr>

### **3) 데이터 수집 최적화: 스마트 키 로테이션**
<br><br><br><br><br><br>


- **배경**: 단일 API 키 호출 제한(1,000회/일)으로 인한 데이터 유실 위기
- **문제 분석**: 13개 노선 1분 주기 수집 시, 키 1개당 약 **1.3~2시간** 내 한도 소진
- **기술적 해결**: **12개의 API 키 리스트**를 활용한 순차적 자동 전환(Relay) 알고리즘 구현
- **기대 효과**: 주요 운행 시간(05~25시) 내 끊김 없는 실시간 데이터 적재 달성



<br>
<br><br><br><br>

---
## **3. 아키텍처 및 엔지니어링 ( ② 시간표 데이터)**
<hr>


### **1) 데이터 가공**
  - **가공 기준**: 실시간 데이터 주요 변수 규격으로 스키마 통일 (**Python**)
  - **기본노선(1~9호선)**: API와 구조가 유사하여 구조 정합성 위주 유지
  - **광역철도(4개 노선)**: 핵심 가공 대상으로 데이터 정규화 수행
    - **구조 매핑**: 파편화된 시트 구조(행/열) 자동 탐색 및 매핑
    - **결측치 복구**: 병합 셀(Null)을 이전 값으로 채우는 기법 적용
    - **변수 변환**: 문자열(상/하행) → 수치형(0/1) 변환 및 타입 일치


### **2) 데이터 적재**
  - **저장소**: **Supabase (PostgreSQL)** 클라우드 DB
  - **적재 방식**: 시간대별 분할 적재 (쿼리 효율 및 가용성 향상)



---
## **3. 아키텍처 및 엔지니어링 ( ② 시간표 데이터)**
<hr>

### **3) 적제 과정**

<br><br><br><br><br><br><br><br><br>

---


## **3. 아키텍처 및 엔지니어링 ( ③ 실시간·시간표 결합 )**
<hr>

### **[Step 1] 열차 상태 필터링 및 도착 시각 확정**



- **[필터링 로직 (0:진입, 1:도착, 2:출발, 3:전역출발 )]**
    - **Target (1순위)**: **진입(0)** 또는 **도착(1)** 상태 중 가장 먼저 수신된 시각을 **도착 시각**으로 확정
    - **Backup (2순위)**: 도착 데이터 누락 시, **출발(2)** 시각을 기반으로 지연 여부 판단
    - **Excluded (제외)**: **전역출발(3)**는 이전 역의 정보이 므로 현재 역의 분석에서 배제


**[SQL Code 일부]**
```sql
-- 도착(0:진입, 1:도착) 중 가장 빠른 시간 추출
MIN(last_rec_time) FILTER (WHERE train_status IN (0, 1)) AS actual_arrival,

-- 출발(2) 시각을 백업용으로 별도 추출
MIN(last_rec_time) FILTER (WHERE train_status = 2) AS actual_departure
```

---

## **3. 아키텍처 및 엔지니어링 ( ③ 실시간·시간표 결합 )**
<hr>

### **[Step 2] 최근 1시간 데이터 갱신 (Slicing)**

- **동작 방식**: 
    - 기존 테이블을 비우고 **최근 1시간 데이터**만 다시 추출하여 적재
- **목적 및 기대효과**:
    - **최신성 유지**: 항상 '지금(Now)' 시점의 가장 정확한 지연 현황 실시간 반영


**[SQL Code 일부]**
```sql
DROP TABLE IF EXISTS "table_1hour";

CREATE TABLE "table_1hour" AS
SELECT * FROM "test1_realtime_summary"
-- 1시간슬라이싱 (성능 효율화의 핵심)
WHERE COALESCE(actual_arrival, actual_departure) >= (NOW() - INTERVAL '1 hour');
```

---

## **3. 아키텍처 및 엔지니어링 ( ③ 실시간·시간표 결합 )**
<hr>

### **[Step 3] 최종 지연 산출 (Delay Calculation)**

- **정밀 매칭 로직**: 호선 + 역 이름 + 방향(상/하행) + **열차 번호(숫자 추출)**
- **신뢰성 확보**: 매칭되지 않는 노이즈 데이터는 배제하여 분석 결과의 정확성 최우선 확보
- **지연 시간 산출 공식**:
    - **Formula**: `실제 도착(또는 출발) 시각 - 시간표 상 계획된 시항` = **delay_duration**



**[SQL Code 일부]**
```sql
-- 두 데이터셋의 1:1 결합 및 지연 산출 (Line 121~127)
SELECT 
    (RT.actual_arrival + interval '9 hours')::time - SC.time_arrive::time AS delay_duration
FROM "table_1hour" AS RT
JOIN daily_schedule AS SC
    ON RT.station_name = SC.station_name 
    AND RT.up_down = SC.up_down




