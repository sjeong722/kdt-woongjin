### 4. 데이터 비교 및 분석 결과 도출

두 데이터셋(실시간 vs 시간표)을 결합하여 **'실시간 지연 시간'**을 산출하는 핵심 분석 알고리즘입니다.

- **분석 알고리즘 아키텍처**
    - **Step 1. 요약 및 정제 (`View` 생성)**: 수만 건의 Raw 로그 데이터를 **'도착/출발' 이벤트 단위**로 정규화.
    - **Step 2. 윈도우 슬라이싱 (Window Slicing)**: 분석 효율을 위해 **최근 1시간** 데이터만 추출하여 메모리 최적화.
    - **Step 3. 매칭 및 지연 계산 (Matching & Calibration)**: 실시간-시간표 데이터를 **1:1 결합(Join)**하여 지연 확정.

---

### [Step 1] 실시간 로그 정규화 (Data Normalization)
- **목표**: 1초마다 쌓이는 수많은 위치 로그 중, **'해당 역에 진짜 도착한 시각'** 하나를 확정하는 과정.
- **알고리즘 상세 (Status Filtering Logic)**:
    1. **상태 필터링 (Priority Selection)**
        - **Target (1순위)**: **진입(0)** & **도착(1)** (가장 정확한 도착 시점)
        - **Backup (2순위)**: **출발(2)** (데이터 누락 시 대체 활용)
        - **Excluded (제외)**: **전역출발(3)** (도착 전이라 오차가 커 노이즈로 간주)
    2. **최소 시간 추출 (First Arrival)**
        - 같은 역/열차 로그 중 **가장 먼저 찍힌 시간**(`MIN`)을 '실제 도착'으로 확정.

### [Step 2] 1시간 윈도우 데이터 갱신 (Snapshot Refresh)
- **동작 방식**: 10분마다 실행하며, 기존 테이블을 비우고(Drop) **최근 1시간 데이터**만 다시 채움(Insert).
- **목적**:
    - 하루 치 전체 데이터를 매번 계산하는 비효율 제거 (**속도 최적화**).
    - 항상 **'지금(Now)'** 기준의 최신 지연 현황 유지.

### [Step 3] 최종 지연 산출 (Delay Calculation)
- **매칭 로직 (1:1 Key Mapping)**:
    - **Key**: `열차번호(Train Code)` + `역이름` + `상하행(0/1)` + `노선명` 이 모두 일치하는 데이터끼리 Join.
    - **상하행 구분**: 같은 역, 같은 열차번호라도 **상행(0)은 상행끼리, 하행(1)은 하행끼리** 매칭하여 오류 방지.

- **지연 공식 (Formula)**:
    $$ \text{Delay} = \text{실제 도착 시각(Live)} - \text{시간표 도착 시각(Schedule)} $$

- **결과물**:
    - **`delay_duration`**: 각 열차/역 별 **지연된 시간(분/초)** 산출 완료.
    - 이 데이터가 Redash 대시보드에 실시간으로 반영되어 **'현재 가장 지연된 노선'** 시각화 가능.

---
**💡 10분 주기 자동화:** 이 모든 과정(Step 1~3)은 Airflow에 의해 **10분마다 자동으로 반복 실행**되어 실시간성을 보장합니다.
