from airflow import DAG
from airflow.providers.common.sql.operators.sql import SQLExecuteQueryOperator
import pendulum
from datetime import datetime, timedelta

# ==========================================
# 1. 기본 설정 (Default Arguments)
# ==========================================
default_args = {
    'owner': 'woals24952495', # <--- Owner 변경
    'depends_on_past': False,
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': 1,
    'retry_delay': timedelta(minutes=1),
}

# ==========================================
# 2. DAG 정의
# ==========================================
dag = DAG(
    'woals24952495_seoul_subway_delay_calculator', # <--- DAG ID 변경 (유니크해야 함)
    default_args=default_args,
    description='10분마다 Supabase 테이블 갱신 및 지연시간 계산',
    schedule='*/10 6-23 * * *',  # [변경] 매일 06시~23시(24시 직전), 10분 간격
    start_date=pendulum.datetime(2026, 1, 15, tz='Asia/Seoul'),   # [변경] 2026년 1월 15일부터 시작
    catchup=False,                     # 과거 밀린 작업은 실행 안 함
    tags=['subway', 'supabase', 'woals24952495'], # <--- Tag 추가
)

# ==========================================
# 3. 실행할 SQL 쿼리 정의
# ==========================================

# Task 1: 데이터 가공 (View 생성) - 실시간 로그를 요약된 형태로 변환
sql_create_view = """
    CREATE OR REPLACE VIEW "test1_realtime_summary" AS
    SELECT
        DATE(last_rec_time) as created_date,
        line_name,
        station_name,
        up_down,
        regexp_replace(train_code, '[^0-9]', '', 'g') as train_code_num,
        is_express,
        dest_station_name,
        -- 도착(0,1) 중 가장 빠른 시간
        MIN(last_rec_time) FILTER (WHERE train_status IN (0, 1)) as actual_arrival,
        -- 출발(2) 중 가장 빠른 시간
        MIN(last_rec_time) FILTER (WHERE train_status = 2) as actual_departure
    FROM "final_realtime_subway"
    GROUP BY 
        DATE(last_rec_time),
        line_name,
        station_name,
        up_down,
        regexp_replace(train_code, '[^0-9]', '', 'g'),
        is_express,
        dest_station_name;
"""

# Task 2: 가공된 View에서 최근 1시간 데이터 추출 (table_1hour)
sql_refresh_1hour = """
    DROP TABLE IF EXISTS "table_1hour";

    CREATE TABLE "table_1hour" AS
    SELECT *
    FROM "test1_realtime_summary"
    -- actual_arrival이 있거나 actual_departure가 있는 데이터 중 최근 것
    WHERE COALESCE(actual_arrival, actual_departure) >= (NOW() - INTERVAL '1 hour');

    ALTER TABLE "table_1hour" ADD COLUMN id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;
"""

# Task 3: 지연 시간 계산 (table_redash_test)
sql_calc_delay = """
    DROP TABLE IF EXISTS "table_redash";

    CREATE TABLE "table_redash" AS
    WITH daily_schedule AS (
        {% set h = data_interval_end.in_timezone("Asia/Seoul").hour %}
        
        -- 06시 ~ 10시: 출근 시간표
        {% if h < 10 %}
            SELECT * FROM "table_attend"
        
        -- 10시 ~ 11시: 출근 + 평시 (겹치는 구간)
        {% elif h == 10 %}
            SELECT * FROM "table_attend" 
            UNION ALL 
            SELECT * FROM "table_noon"
            
        -- 11시 ~ 18시: 평시 시간표
        {% elif h < 18 %}
            SELECT * FROM "table_noon"
            
        -- 18시 ~ 19시: 평시 + 퇴근/막차 (겹치는 구간)
        {% elif h == 18 %}
            SELECT * FROM "table_noon" 
            UNION ALL 
            SELECT * FROM "table_night"
            
        -- 19시 이후: 퇴근/막차 시간표
        {% else %}
            SELECT * FROM "table_night"
        {% endif %}
    )
    SELECT 
        RT.created_date,
        RT.line_name,
        RT.station_name,
        RT.up_down,
        RT.train_code_num,
        RT.is_express,
        RT.dest_station_name,
        
        -- [시간 확인용]
        RT.actual_arrival AS utc_arrival, 
        (RT.actual_arrival + interval '9 hours') AS kst_arrival, 
        SC.time_arrive AS scheduled_arrival_text,
        
        -- [지연 시간 계산]
        CASE 
            WHEN RT.actual_arrival IS NOT NULL THEN 
                ((RT.actual_arrival + interval '9 hours')::time - SC.time_arrive::time)
            ELSE 
               ((RT.actual_departure + interval '9 hours')::time - SC.time_depart::time)
        END AS delay_duration

    FROM "table_1hour" AS RT
    JOIN daily_schedule AS SC
        ON RT.line_name = SC.line_name
        AND RT.station_name = SC.station_name
        AND RT.up_down = SC.up_down 
        AND RT.is_express = SC.is_express 
        -- 열차번호 숫자 매칭
        AND CAST(RT.train_code_num AS INTEGER) 
          = CAST(REGEXP_REPLACE(SC.train_code::text, '\D', '', 'g') AS INTEGER);

    -- [Task B] ID 중복 방지
    ALTER TABLE "table_redash" DROP COLUMN IF EXISTS id;
    ALTER TABLE "table_redash" ADD COLUMN id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;
"""

# Task 4: 계산된 결과를 History 테이블에 누적 (table_redash_history)
sql_append_history = """
    -- 1. History 테이블이 없으면 생성 (최초 1회)
    CREATE TABLE IF NOT EXISTS "table_redash_history" (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        created_date DATE,
        line_name TEXT,
        station_name TEXT,
        up_down TEXT,
        train_code_num TEXT,
        is_express TEXT,
        dest_station_name TEXT,
        utc_arrival TIMESTAMP,
        kst_arrival TIMESTAMP,
        scheduled_arrival_text TEXT,
        delay_duration INTERVAL,
        inserted_at TIMESTAMP DEFAULT NOW(),
        -- 중복 방지를 위한 유니크 제약조건 (필요 시 조정 가능)
        CONSTRAINT unique_history_record UNIQUE (created_date, line_name, station_name, train_code_num, kst_arrival)
    );

    -- 2. 데이터 Insert (중복 발생 시 무시 - DO NOTHING)
    INSERT INTO "table_redash_history" (
        created_date, line_name, station_name, up_down, train_code_num, 
        is_express, dest_station_name, utc_arrival, kst_arrival, 
        scheduled_arrival_text, delay_duration
    )
    SELECT 
        created_date, line_name, station_name, up_down, train_code_num, 
        is_express, dest_station_name, utc_arrival, kst_arrival, 
        scheduled_arrival_text, delay_duration
    FROM "table_redash"
    ON CONFLICT ON CONSTRAINT unique_history_record DO NOTHING;
"""

# ==========================================
# 4. Task 정의 (SQLExecuteQueryOperator 사용)
# ==========================================

t1_create_view = SQLExecuteQueryOperator(
    task_id='create_view_summary',
    conn_id='jaemin1077_supabase_conn',
    sql=sql_create_view,
    dag=dag,
)

t2_refresh_1hour = SQLExecuteQueryOperator(
    task_id='refresh_table_1hour',
    conn_id='jaemin1077_supabase_conn', 
    sql=sql_refresh_1hour,
    dag=dag,
)

t3_calc_delay = SQLExecuteQueryOperator(
    task_id='refresh_table_redash_test',
    conn_id='jaemin1077_supabase_conn',
    sql=sql_calc_delay,
    dag=dag,
)

t4_append_history = SQLExecuteQueryOperator(
    task_id='append_to_history',
    conn_id='jaemin1077_supabase_conn',
    sql=sql_append_history,
    dag=dag,
)

# ==========================================
# 5. 실행 순서 설정
# ==========================================
# 뷰 생성/갱신 -> 1시간 데이터 추출 -> 지연 계산 -> 히스토리 적재
t1_create_view >> t2_refresh_1hour >> t3_calc_delay >> t4_append_history