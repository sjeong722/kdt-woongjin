from airflow import DAG
from airflow.providers.common.sql.operators.sql import SQLExecuteQueryOperator
import pendulum
from datetime import datetime, timedelta

# ==========================================
# 1. 기본 설정 (Default Arguments)
# ==========================================
default_args = {
    'owner': 'woals24952495', 
    'depends_on_past': False,
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': 1,
    'retry_delay': timedelta(minutes=1),
}

# ==========================================
# 2. DAG 정의
# ==========================================
dag = DAG(
    'woals24952495_delay_cal', # <--- DAG ID 변경 (06~10시 출근시간 전용)
    default_args=default_args,
    description='06~10시 출근시간 전용 지연시간 계산 (table_attend 비교)',
    schedule='*/10 6-9 * * *',  # [변경] 매일 06시~9시50분, 10분 간격
    start_date=pendulum.datetime(2026, 1, 15, tz='Asia/Seoul'),
    catchup=False,                     
    tags=['subway', 'supabase', 'woals24952495', 'attend_only'], 
)

# ==========================================
# 3. 실행할 SQL 쿼리 정의
# ==========================================

# Task 1: 데이터 가공 (View 생성) - 기존과 동일하게 사용 (이미 생성되어 있다면 생략 가능하지만 안전하게 재실행)
sql_create_view = """
    CREATE OR REPLACE VIEW "test1_realtime_summary_attend" AS
    SELECT
        DATE(last_rec_time) as created_date,
        line_name,
        station_name,
        up_down,
        regexp_replace(train_code, '[^0-9]', '', 'g') as train_code_num,
        is_express,
        dest_station_name,
        -- 도착(0,1) 중 가장 빠른 시간
        MIN(last_rec_time) FILTER (WHERE train_status IN (0, 1)) as actual_arrival,
        -- 출발(2) 중 가장 빠른 시간
        MIN(last_rec_time) FILTER (WHERE train_status = 2) as actual_departure
    FROM "final_realtime_subway"
    GROUP BY 
        DATE(last_rec_time),
        line_name,
        station_name,
        up_down,
        regexp_replace(train_code, '[^0-9]', '', 'g'),
        is_express,
        dest_station_name;
"""

# Task 2: 가공된 View에서 최근 1시간 데이터 추출 (table_1hour_attend)
sql_refresh_1hour = """
    DROP TABLE IF EXISTS "table_1hour_attend";

    CREATE TABLE "table_1hour_attend" AS
    SELECT *
    FROM "test1_realtime_summary_attend"
    -- actual_arrival이 있거나 actual_departure가 있는 데이터 중 최근 것
    WHERE COALESCE(actual_arrival, actual_departure) >= (NOW() - INTERVAL '1 hour');

    ALTER TABLE "table_1hour_attend" ADD COLUMN id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;
"""

# Task 3: 지연 시간 계산 (table_redash_attend) - 오직 table_attend와만 비교
sql_calc_delay_attend = """
    DROP TABLE IF EXISTS "table_redash_attend";

    CREATE TABLE "table_redash_attend" AS
    SELECT 
        RT.created_date,
        RT.line_name,
        RT.station_name,
        RT.up_down,
        RT.train_code_num,
        RT.is_express,
        RT.dest_station_name,
        
        -- [시간 확인용]
        RT.actual_arrival AS utc_arrival, 
        (RT.actual_arrival + interval '9 hours') AS kst_arrival, 
        SC.time_arrive AS scheduled_arrival_text,
        
        -- [지연 시간 계산]
        CASE 
            WHEN RT.actual_arrival IS NOT NULL THEN 
                ((RT.actual_arrival + interval '9 hours')::time - SC.time_arrive::time)
            ELSE 
               ((RT.actual_departure + interval '9 hours')::time - SC.time_depart::time)
        END AS delay_duration

    FROM "table_1hour_attend" AS RT
    JOIN "table_attend" AS SC  -- 무조건 table_attend와 조인
        ON RT.line_name = SC.line_name
        AND RT.station_name = SC.station_name
        AND RT.up_down = SC.up_down 
        AND RT.is_express = SC.is_express 
        -- 열차번호 숫자 매칭
        AND CAST(RT.train_code_num AS INTEGER) 
          = CAST(REGEXP_REPLACE(SC.train_code::text, '\D', '', 'g') AS INTEGER);

    -- [Task B] ID 중복 방지 및 기본키 생성
    ALTER TABLE "table_redash_attend" DROP COLUMN IF EXISTS id;
    ALTER TABLE "table_redash_attend" ADD COLUMN id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;
"""

# ==========================================
# 4. Task 정의 (SQLExecuteQueryOperator 사용)
# ==========================================

t1_create_view = SQLExecuteQueryOperator(
    task_id='create_view_summary',
    conn_id='jaemin1077_supabase_conn',
    sql=sql_create_view,
    dag=dag,
)

t2_refresh_1hour = SQLExecuteQueryOperator(
    task_id='refresh_table_1hour',
    conn_id='jaemin1077_supabase_conn', 
    sql=sql_refresh_1hour,
    dag=dag,
)

t3_calc_delay = SQLExecuteQueryOperator(
    task_id='refresh_table_redash_attend',
    conn_id='jaemin1077_supabase_conn',
    sql=sql_calc_delay_attend,
    dag=dag,
)

# ==========================================
# 5. 실행 순서 설정
# ==========================================
t1_create_view >> t2_refresh_1hour >> t3_calc_delay
